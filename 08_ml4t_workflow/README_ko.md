# ML4T 워크플로: ML 모델에서 전략 백테스트까지

이 장에서는 거래를 위한 기계 학습(ML4T) 워크플로의 다양한 구성 요소를 통합하고 ML 기반 거래 전략을 설계, 시뮬레이션 및 평가하는 프로세스에 대한 엔드투엔드 관점을 제시합니다. 가장 중요한 것은 Python 라이브러리 backtrader 및 Zipline을 사용하여 백테스트를 준비, 설계, 실행 및 평가하는 방법을 더 자세히 보여줍니다.

ML4T 워크플로의 궁극적인 목표는 실제 시장에서 후보 전략을 배포하고 재정 자원을 위험에 빠뜨릴지 여부를 결정하는 데 도움이 되는 과거 데이터에서 증거를 수집하는 것입니다. 이 프로세스는 이전 장에서 개발한 기술을 기반으로 합니다.

- 정보 요소를 엔지니어링하기 위해 다양한 데이터 소스를 사용하여 작업합니다. 
- 거래 전략을 알리기 위해 예측 신호를 생성하는 ML 모델을 설계합니다. 
- 위험-수익 관점에서 결과 포트폴리오를 최적화합니다.

또한 전략을 현실적으로 시뮬레이션하려면 보안 시장의 운영 방식과 거래 실행 방식을 충실하게 나타내야 합니다. 따라서 사용 가능한 주문 유형 및 가격 결정 방법과 같은 거래소의 제도적 세부 정보(`zipline` 참조)는 백테스트를 설계하거나 백테스팅 엔진에 정확한 성능 측정을 위한 필수 기능이 포함되어 있는지 평가할 때도 중요합니다. 마지막으로 다음과 같은 사항이 있습니다. 잘못된 투자 결정으로 이어질 수 있는 편향된 결과와 잘못된 발견을 피하기 위해 주의가 필요한 몇 가지 방법론적 측면.

일부 백테스트 시뮬레이션에 사용되는 데이터는 [데이터](00_data) 디렉터리의 [data_prep.py](00_data/data_prep.py) 스크립트에 의해 생성되며 [7장, 선형 모델](../07_linear_models)의 선형 회귀 반환 예측을 기반으로 합니다.

## 콘텐츠

1. __자리표시자_4__
2. __자리표시자_5__
    * __자리표시자_6__
    * __자리표시자_7__
    * __자리표시자_8__
    * __자리표시자_9__
    * __자리표시자_10__
3. __자리표시자_11__
    * __자리표시자_12__
    * __자리표시자_13__
    * __자리표시자_14__
4. __자리표시자_15__
    * __자리표시자_16__
    * __자리표시자_17__
    * __자리표시자_18__
5. __자리표시자_19__
    * __자리표시자_20__

## ML 기반 전략을 백테스트하는 방법

간단히 말해서 ML4T 워크플로는 기계 학습을 활용하여 거래 신호를 생성하고 포지션을 선택 및 크기를 지정하거나 거래 실행을 최적화하는 거래 전략을 백테스트하는 것입니다. 여기에는 특정 투자 대상과 범위를 염두에 두고 다음 단계가 포함됩니다.
- 시장, 기초, 대체 데이터 확보 및 준비
- 엔지니어 예측 알파 요소 및 기능
- 거래 신호를 생성하기 위한 ML 모델 설계, 조정 및 평가
- 이러한 신호를 기반으로 거래를 결정합니다. 규칙을 적용하여
- 포트폴리오 맥락에서 개별 위치의 크기를 조정합니다.
- 과거 시장 데이터를 사용하여 발생한 거래 결과를 시뮬레이션합니다.
- 결과 위치가 어떻게 수행되었을지 평가합니다.

<p 정렬="중앙">
<img src="https://i.imgur.com/kcgItgp.png" width="75%">
</p>

## 백테스팅의 함정과 이를 피하는 방법

백테스팅은 새로운 시장 조건에 일반화되는 성과 결과를 생성한다는 목표로 과거 데이터를 기반으로 알고리즘 전략을 시뮬레이션합니다. 끊임없이 변화하는 시장 상황에서 예측에 대한 일반적인 불확실성 외에도 여러 구현 측면으로 인해 결과가 편향될 수 있으며 표본 내 성능을 표본 외 패턴으로 착각할 위험이 커질 수 있습니다.

### 올바른 데이터 얻기

백테스트의 타당성을 훼손하는 데이터 문제는 다음과 같습니다. 
- 예견 편향, 
- 생존 편향, 
- 이상값 제어뿐만 아니라 
- 샘플 기간의 선택.

### 시뮬레이션을 올바르게 수행하기

과거 시뮬레이션 구현과 관련된 실제 문제는 다음과 같습니다.
- 시장 가격을 정확하게 반영하고 인하액을 설명하기 위한 시장 표시 실패; 
- 거래의 가용성, 비용 또는 시장 영향에 대한 비현실적인 가정 또는 
- 신호 및 거래 실행의 타이밍이 잘못되었습니다.
 
### 올바른 측정 수준: 데이터 스누핑 및 백테스트과 적합

게시된 결과를 포함하여 백테스트 유효성에 대한 가장 눈에 띄는 문제는 전략 선택 프로세스 중 여러 테스트로 인한 허위 패턴 발견과 관련이 있습니다. 동일한 데이터에 대해 서로 다른 후보를 테스트한 후 전략을 선택하면 긍정적인 결과가 성능 측정 자체의 확률론적 특성으로 인해 발생할 가능성이 높기 때문에 선택이 편향될 가능성이 높습니다. 즉, 전략이 현재 데이터에 과도하게 맞춤화되거나 과적합되어 믿을 수 없을 만큼 긍정적인 결과를 생성합니다.

[마르코스 로페즈 드 프라도](http://www.quantresearch.info/)은 백테스팅의 위험과 이를 감지하거나 방지하는 방법에 대해 광범위하게 출판했습니다. 여기에는 [백테스트 과적합의 온라인 시뮬레이터](http://datagrid.lbl.gov/backtest/)이 포함됩니다.

### 코드 예: 위축된 샤프 비율

De Lopez Prado와 David Bailey는 다중 테스트, 비정규 수익률 및 짧은 표본 길이의 인플레이션 효과를 제어하면서 SR이 통계적으로 유의할 확률을 계산하기 위해 수축된 SR을 도출했습니다.

[다중 테스트](01_multiple_testing) 디렉터리의 Python 스크립트 [deflated_shape_ratio](01_multiple_testing/deflated_sharpe_ratio.py)에는 관련 공식 파생에 대한 참조와 함께 Python 구현이 포함되어 있습니다.

### 참고자료

- [수축된 샤프 비율: 선택 편향, 백테스트 과적합 및 비정규성에 대한 수정](https://www.davidhbailey.com/dhbpapers/deflated-sharpe.pdf), Bailey, David 및 Lopez de Prado, Marcos, 포트폴리오 관리 저널, 2013
- __자리표시자_26__
- [백테스팅](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2606462), 로페즈 드 프라도, 마르코스, 2015
- __자리표시자_28__
- [최적의 정지 및 적용](https://www.math.ucla.edu/~tom/Stopping/Contents.html), 퍼거슨, UCLA 수학과
- [머신러닝 강의의 발전 4/10 - 백테스팅 I](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3257420), 마르코스 로페즈 드 프라도, 2018
- [머신러닝의 발전 강의 5/10 - 백테스팅 II](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3257497), 마르코스 로페즈 드 프라도, 2018

## 백테스팅 엔진의 작동 방식

간단히 말해서, 백테스팅 엔진은 과거 가격(및 기타 데이터)을 반복하고, 현재 값을 알고리즘에 전달하고, 그에 대한 대가로 주문을 받고, 결과 포지션과 해당 값을 추적합니다. 실제로 위에 설명된 ML4T 워크플로의 현실적이고 강력한 시뮬레이션을 생성하려면 수많은 요구 사항이 있습니다. 벡터화된 접근 방식과 이벤트 기반 접근 방식의 차이점은 실제 거래 환경을 충실하게 재현하면 상당한 복잡성이 어떻게 추가되는지를 보여줍니다.

### 벡터화 대 이벤트 기반 백테스팅

벡터화된 백테스트는 전략을 평가하는 가장 기본적인 방법입니다. 단순히 목표 포지션 크기를 나타내는 신호 벡터와 투자 기간에 대한 수익 벡터를 곱하여 기간 성과를 계산합니다.

### 코드 예: 간단한 벡터화된 백테스트

[제7장](../07_linear_models)에서 능선 회귀를 사용하여 생성한 일일 수익률 예측을 사용하여 벡터화된 접근 방식을 설명합니다.

- 이 섹션의 코드 예제는 [벡터화된_백테스트](02_vectorized_backtest.ipynb) 노트북에 있습니다.

### 주요 구현 측면

현실적인 시뮬레이션을 위한 요구 사항은 프로세스의 모든 단계를 엔드투엔드 방식으로 지원하는 단일 플랫폼이나 각기 다른 측면을 전문으로 하는 여러 도구를 통해 충족될 수 있습니다. 예를 들어, scikit-learn이나 이 책에서 접하게 될 다른 라이브러리와 같은 일반 ML 라이브러리를 사용하여 신호를 생성하고 모델 출력을 별도의 백테스팅 엔진에 공급하는 ML 모델의 설계 및 테스트를 처리할 수 있습니다. 또는 Quantopian 및 QuantConnect와 같은 단일 플랫폼에서 전체 ML4T 워크플로를 엔드 투 엔드로 실행할 수 있습니다.

이 프로세스를 실행하려면 다음 구현 세부 사항을 해결해야 하며 이 섹션에서 자세히 설명합니다.
- 데이터 수집: 형식, 빈도 및 타이밍
- 요인 엔지니어링: 내장 계산과 타사 라이브러리 비교
- ML 모델, 예측 및 신호
- 거래 규칙 및 실행
- 성과평가

## backtrader: 로컬 백테스트를 위한 유연한 도구

backtrader는 Daniel Rodriguez가 2015년부터 개발한 훌륭한 문서가 포함된 로컬 백테스트를 위한 인기 있고 유연하며 사용자 친화적인 Python 라이브러리입니다. 개별 거래자로 구성된 대규모의 활동적인 커뮤니티 외에도 백트레이더를 사용하여 새로운 전략을 프로토타입화하고 테스트한 후 Java 등을 사용하여 생산 가능한 플랫폼으로 포팅하는 여러 은행 및 거래 회사가 있습니다. 또한 선택한 여러 브로커와의 실시간 거래를 위해 백트레이더를 사용할 수도 있습니다(백트레이더 [선적 서류 비치](https://www.backtrader.com/docu/) 및 [23장, 다음 단계](../23_next_steps) 참조).

- 이 섹션의 코드 예제는 __PLACEHOLDER__ 36 __ 노트북에 있습니다.

### 백트레이더의 Cerebro 아키텍처의 주요 개념

Backtrader의 Cerebro(스페인어로 "뇌") 아키텍처는 백테스팅 작업 흐름의 핵심 구성 요소를 (확장 가능한) Python 개체로 나타냅니다. 이러한 개체는 상호 작용하여 입력 데이터 처리 및 요소 계산을 촉진하고, 전략을 공식화 및 실행하고, 주문을 수신 및 실행하고, 성과를 추적 및 측정합니다. Cerebro 인스턴스는 입력 수집, 막대별 백테스트 실행, 결과 제공 등 전체 프로세스를 조율합니다.

라이브러리는 일부 세부 사항을 생략하고 백테스팅 설정을 간소화할 수 있도록 이러한 상호 작용에 대한 규칙을 사용합니다. 자신만의 전략을 개발하기 위해 백트레이더를 사용할 계획이라면 [선적 서류 비치](https://www.backtrader.com/docu/)을 탐색하여 더 자세히 알아보는 것이 좋습니다.

<p 정렬="중앙">
<img src="https://i.imgur.com/MTp7UaQ.png" width="75%">
</p>

### 코드 예시: 백트레이더를 실제로 사용하는 방법

우리는 이 장 앞부분의 벡터화된 백테스트와 마찬가지로 7장 선형 모델의 능선 회귀에 의한 일일 수익률 예측을 다시 사용하여 백트레이더를 시연할 것입니다. Cerebro 인스턴스를 생성하고, 데이터를 로드하고, 전략을 공식화 및 추가하고, 백테스트를 실행하고, 결과를 검토하겠습니다.

노트북 [백테스팅_with_backtrader](03_backtesting_with_backtrader.ipynb)에는 코드 예제와 몇 가지 추가 세부정보가 포함되어 있습니다.

### 자원

- [백트레이더](https://www.backtrader.com/) 웹사이트 
    - __자리표시자_40__
    - __자리표시자_41__

## zipline: Quantopian의 생산 준비 백테스팅

오픈 소스 [지퍼 라인](https://zipline.ml4trading.io/index.html) 라이브러리는 알고리즘 개발 및 실시간 거래를 촉진하기 위해 크라우드 소싱 정량 투자 펀드 [양자역학](https://www.quantopian.com/)에서 생산에 유지 관리하고 사용하는 이벤트 중심 백테스팅 시스템입니다. 이는 거래 이벤트에 대한 알고리즘의 반응을 자동화하고 예측 편향을 방지하는 현재 및 과거 시점 데이터를 제공합니다.

[제4장](../04_alpha_factor_research)에서는 알파 팩터 계산을 시뮬레이션하기 위해 [2장, 시장 및 기본 데이터](../02_market_and_fundamental_data)을 도입했고, [제5장](../05_strategy_evaluation)에서는 거래를 추가하여 간단한 전략을 시뮬레이션하고 성과를 측정하며 다양한 기술을 사용하여 포트폴리오 보유를 최적화했습니다.

### 코드 예제: 오프라인 및 Quantopian에서 데이터 수집 및 ML 모델 교육

이 섹션의 코드는 하위 디렉터리 [ml4t_workflow_with_zipline](04_ml4t_workflow_with_zipline)에 있습니다. 자세한 내용은 [읽어보기](04_ml4t_workflow_with_zipline/README.md)을 참조하세요.